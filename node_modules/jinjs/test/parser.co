#!/usr/bin/env coco
{ make_expression } = require \../lib/expression

{ fail, ok, equal, notEqual, deepEqual, notDeepEqual, strictEqual, notStrictEqual, throws, doesNotThrow, ifError } = require \assert
{ EventEmitter } = require \events
{ JinJSParseError } = require \../lib/nodes

optimist = require \optimist
    .usage "$0: run the test suite."
    .alias \verbose, \v
    .alias \help, \h
    .describe \verbose, "Show all the tests"
    .describe \help, "You're staring at it"
{ argv } = optimist

{ Environment } = require \../lib/environment
e = new Environment filter_exp: 'require(\"../lib/filters\")', util_exp: 'require(\"../lib/utils\")'

test_context = do
    foo: "foo"
    bar: "bar"
    one: 1

run = (str, ctx) ->
    try
        exports = {} # Necessary to get the render() function
        compiled = e.getTemplateSourceFromString str
        eval compiled
        result = exports.render ctx
        return result
    catch e
        if e instanceof SyntaxError
            console.log compiled
        throw e

function parse (txt, ctx) ->
    return ->
        if not ctx
            ctx := {} <<< test_context
        res = run txt, ctx
        return txt: res, ctx: ctx

_parse = (txt, ctx) -> (parse txt, ctx)()

function compile (txt) ->
    try
        exports = {}
        compiled = e.getTemplateSourceFromString txt
        eval compiled
        return exports
    catch e
        if e instanceof SyntaxError
            console.log compiled
        throw e

parseError = (fn) -> throws fn, JinJSParseError

suite = require \vows .describe "Expressions Test Suite"


suite.addBatch do
    "The {% let %} tag": do
        topic: parse "{% let toto = 1 %}TXT"

        "Lets us assign to a variable that is later exported": (res) ->
            equal res.ctx.toto, 1

        "Does not output anything": (res) ->
            equal res.txt, 'TXT'

        "does not let us assign to reserved-words variables": (res) ->
            parseError -> _parse "{% let instanceof = 3 %}"

    ##
    ##  IF TAG
    ##

    "The {% if %} and {% elseif %} tags": do

        "displays text when its condition is met": ->
            res = _parse "{% if one == 1 %}TXT{% endif %}"
            equal res.txt, 'TXT'

        "does not display text if its condition is not met": ->
            res = _parse "{% if one == 2 %}TXT{% endif %}"
            equal res.txt, ''

        "displays its first close if its condition is met": ->
            res = _parse "{% if one == 1 %}TXT{% else %}FOO{% endif %}"
            equal res.txt, 'TXT'
        
        "displays its else close if its condition is not met": ->
            res = _parse "{% if one == 2 %}TXT{% else %}FOO{% endif %}"
            equal res.txt, 'FOO'

        "can have several ifelse clauses": ->
            res = _parse "{% if one == 2 %}TXT{% elseif one == 1 %}FO1{% elseif one == 3 %}FO3{% else %}FOO{% endif %}"
            equal res.txt, 'FO1'

        "can not be condition-less": ->
            throws (-> _parse "{% if %}TXT{% endif %}"), JinJSParseError
            throws (-> _parse "{% if one == 1 %}TXT{% elseif %}{% endif %}"), JinJSParseError

    ##
    ##  FOR TAG
    ##

    "The {% for %} tag": do

        "is of the form <variable> in <array>": ->
            throws (-> _parse "{% for in toto %}TXT{% endfor %}"), JinJSParseError
            doesNotThrow -> _parse "{% for value in toto %}TXT{% endfor %}"

        "is used to iterate over an array": ->
            res = _parse "{% for val in [4, 5, 4] %}{{ val }}{% endfor %}"
            equal res.txt, '454'

        "has a {{ loop.index0 }} variable": ->
            res = _parse "{% for val in [4, 5, 4] %}{{ loop.index0 }}{% endfor %}"
            equal res.txt, '012'
            
        "has a {{ loop.index }} variable": ->
            res = _parse "{% for val in [4, 5, 4] %}{{ loop.index }}{% endfor %}"
            equal res.txt, '123'

        "has a {{ loop.first }} variable": ->
            res = _parse "{% for val in [4, 5, 6] %}{% if loop.first %}F{% endif %}{{ loop.index }}{% endfor %}"
            equal res.txt, 'F123'
            
        "has a {{ loop.last }} variable": ->
            res = _parse "{% for val in [4, 5, 6] %}{% if loop.last %}L{% endif %}{{ loop.index }}{% endfor %}"
            equal res.txt, '12L3'
            
        "is also of the form <key>, <value> in <object>": ->
            doesNotThrow -> _parse "{% for key, value in toto %}TXT{% endfor %}"
            
        "outputs keys and values of objects": ->
            res = _parse "{% for key, val in {a: 1, b: 2} %}{{ key }}:{{val}} {% endfor %}"
            equal res.txt, 'a:1 b:2 '

        "accepts the empty object and does not output anything": ->
            res = _parse "{% for key, val in { } %}{{ key }}:{{val}} {% endfor %}"
            equal res.txt, ''

        "can have another {% for %} inside without messing up the variables": ->
            res = _parse "{% for key, val in {a:1, b:2} %}{% for key in [1,2,3] %}{{ key }}{% endfor %}{{ key }}:{{val}}{% endfor %}"
            equal res.txt, '123a:1123b:2'

        "does not leave its variable in the environment": ->
            res = _parse "{% for key, val in { } %}{{ key }}:{{val}} {% endfor %}"
            equal res.ctx.key, undefined
            equal res.ctx.val, undefined


        # Should investigate the whole "callee thing"
        # "can be called recursively": ->

    ##
    ##  {{ }}
    ##

    "The {{ print }} statement": do

        "does not output undefined or null values": ->
            res = _parse "{{ null }}{{ undefined }}"
            equal res.txt, ''

        "displays the string result of an expression": ->
            res = _parse "{{ foo }}"
            equal res.txt, 'foo'

    "The |filters": do
        "allow us to pass values through functions differently": ->
            res = _parse "{{ bobo|default('bobo is not defined') }}"
            equal res.txt, 'bobo is not defined'

    "The {% extends %} tag": do

        "allows a template to extend another": ->
            base = compile "base"
            res = _parse "{% extends base %}should not see me", (base: base)
            equal res.txt, 'base'

        "does not let us extend null or undefined variables": ->
            throws -> _parse "{% extends null %}"
            throws -> _parse "{% extends bloub %}"


    "The {% include %} tag": do
        "allows us to include the contents of a template into another": ->
            included = compile "hello"
            res = _parse "{% include included %} world !", included: included
            equal res.txt, 'hello world !'

        "sends the current context to the included tag": ->
            included = compile "{{ foo }}"
            res = _parse "{% include included %}", foo: "foo", included: included
            equal res.txt, 'foo'

        "gets to modify the context": ->
            included = compile "{% let foo = 'bar' %}"
            res = _parse "{% include included %}{{ foo }}", foo: "foo", included: included
            equal res.txt, 'bar'

    "The {% block %} tag": do

        "can be nested": ->
            extended = compile "{% block orig %}original{% block nested %} nested{% endblock %}{% endblock %}"
            res = _parse "{% extends ext %}", ext: extended
            equal res.txt, "original nested" 

        "can have redefined nested blocks": ->
            extended = compile "{% block orig %}hello {% block nested %}bold{% endblock %}{% endblock %}"
            res = _parse "{% extends ext %}{% block nested %}world{% endblock %}", ext: extended
            equal res.txt, "hello world" 

        "defines a super() function for previous blocks": ->
            base = compile "{% block b %}hello{% endblock %}"
            res = _parse "{% extends base %}{% block b %}{{ super() }} world{% endblock %}" base: base
            equal res.txt, 'hello world'

        "can be redefined in child templates": ->
            base = compile ":{% block b %}should not see me{% endblock %}:"
            res = _parse "{% extends base %}should not see me{% block b %}hello{% endblock %}", base: base
            equal res.txt, ':hello:'

        "allows us to have blocks redefined in various child templates": ->
            base = compile ":{% block b %}should not see me{% endblock %}:"
            base2 = compile "{% extends base %}={% block b %}should still not see me{% endblock %}="
            res = _parse "{% extends base2 %}should not see me{% block b %}hello{% endblock %}", base: base, base2: base2
            equal res.txt, ':hello:'


    "The {% import %} tag": do

        "allows us to import variables from another template to another": ->
            imported = compile "{% let foo = 'bar' %}"
            res = _parse "{% from imported import foo %}{{ foo }}", imported: imported
            equal res.txt, 'bar'

        "allows us to import a whole template as a module": ->
            imported = compile "{% let foo = 'bar' %}"
            res = _parse "{% import imported as imp %}{{ imp.foo }}", imported: imported
            equal res.txt, 'bar'

        "by default does not expose the current context to the imported module": ->
            imported = compile "{% let foo = 'bar' %}"
            res = _parse "{% import imported as toto %}{{ foo }}", imported: imported, foo: 'foo'
            equal res.txt, 'foo'

        "can pass the context to the imported template": ->
            imported = compile "{% let foo = bar + 'foo' %}"
            res = _parse "{% import imported as toto with context %}{{ toto.foo }}", imported: imported, bar: 'bar'
            equal res.txt, 'barfoo'

    "The {% abspath %} tag": do

        "Outputs the absolute path of the given string": ->
            res = _parse "{% abspath 'toto' %}"
            equal res.txt, (require \path .join __dirname, \toto)

    "The {% macro %} tag": do

        "Allows us to define functions": ->
            res = _parse "{% macro test (a, b) %}{{ a }} {{ b }}.{% endmacro %}{{ test ('Hello', 'World') }}"
            equal res.txt, "Hello World."

        "Can have arguments with default values": ->
            res = _parse "{% macro test (a, b='World') %}{{ a }} {{ b }}.{% endmacro %}{{ test ('Hello') }}"
            equal res.txt, "Hello World."

        "have arguments which default values are overriden when specified in the function call": ->
            res = _parse "{% macro test (a, b='Not World') %}{{ a }} {{ b }}.{% endmacro %}{{ test ('Hello', 'World') }}"
            equal res.txt, "Hello World."
            

if argv.help
    console.log optimist.usage()
    process.exit 0

if argv.verbose
    suite.run reporter: require \vows/lib/vows/reporters/spec
else
    suite.run()
