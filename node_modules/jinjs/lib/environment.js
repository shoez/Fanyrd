var Parser, render_template, watchFile, readFileSync, join, dirname, Environment, BasicFileEnvironment, _ref, __extends = function(sub, sup){
  function ctor(){} ctor.prototype = (sub.superclass = sup).prototype;
  return (sub.prototype = new ctor).constructor = sub;
};
Parser = require('./parser').Parser;
render_template = require('./module_template').render;
_ref = require('fs'), watchFile = _ref.watchFile, readFileSync = _ref.readFileSync;
_ref = require('path'), join = _ref.join, dirname = _ref.dirname;
/**
 *  A very basic environment.
 */
Environment = (function(){
  var $evalTemplateObject, prototype = Environment.prototype;
  $evalTemplateObject = function(t, env){
    var environment;
    environment = env;
    return eval(t);
  };
  function Environment(specs){
    var _ref;
    specs == null && (specs = {});
    this.filter_exp = specs.filter_exp;
    this.require_exp = specs.require_exp;
    this.util_exp = specs.util_exp;
    this.parser = (_ref = specs.parser) != null
      ? _ref
      : new Parser();
    this.pre_compile_func = specs.pre_compile_func;
  } Environment.displayName = 'Environment';
  prototype.getTemplateFromString = function(str){
    var exports, compiled;
    try {
      exports = {};
      compiled = this.getTemplateSourceFromString(str);
      eval(compiled);
      return exports;
    } catch (e) {
      if (e instanceof SyntaxError) {
        console.log(compiled);
      }
      throw e;
    }
  };
  prototype.getTemplateSourceFromString = function(str){
    var ast, opts, body;
    if (this.pre_compile_func) {
      str = this.pre_compile_func(str);
    }
    ast = this.parser.parse(str);
    opts = {
      __indent__: 1
    };
    body = ast.compile(opts, {});
    opts.body = body;
    opts.filter_exp = this.filter_exp;
    opts.require_exp = this.require_exp;
    opts.util_exp = this.util_exp;
    return render_template(opts);
  };
  return Environment;
}());
/**
 *  A basic file compilation environment. It has no notion of template
 *  directories to look in ; it expects getTemplate() to be provided with
 *  an absolute path to its template.
 *
 *  Inside templates, templates can be called by relative paths however.
 *
 *  If a file doesn't exist, this environment will just crash and burn, as
 *  it makes no checks whatsoever.
 */
BasicFileEnvironment = (function(_super){
  /**
   *  Constructor.
   */
  var prototype = __extends(BasicFileEnvironment, _super).prototype;
  function BasicFileEnvironment(specs){
    specs.require_exp = "__load_template";
    BasicFileEnvironment.superclass.apply(this, arguments);
    this.cache = {};
    this.tracked = {};
    this.deps = {};
  } BasicFileEnvironment.displayName = 'BasicFileEnvironment';
  /**
   *  Invalidate the files that depend on the template at path.
   *  @param path: The base template.
   */
  prototype.invalidateDeps = function(path){
    var file, deps, _ref, _ref2;
    for (file in _ref = this.deps) {
      deps = _ref[file];
      if (path in deps) {
        delete this.cache[file];
        this.invalidateDeps(file);
      }
    }
    return _ref2 = (_ref = this.deps)[path], delete _ref[path], _ref2;
  };
  /**
   *  @param path: The path to monitor for changes.
   */
  prototype.trackFile = function(path){
    var _this = this;
    if (!(path in this.tracked)) {
      this.tracked[path] = true;
      return watchFile(path, function(curr, prev){
        if (curr.mtime > prev.mtime) {
          delete _this.cache[path];
        }
        return _this.invalidateDeps(path);
      });
    }
  };
  /**
   *  @param  path: An absolute path.
   *  @throws Error if the path does not exist.
   */
  prototype.getTemplate = function(path){
    var result;
    if (path in this.cache) {
      return this.cache[path];
    }
    result = readFileSync(path, 'utf-8');
    result = this.getTemplateFromString(result, {
      filename: path,
      root: dirname(path)
    });
    this.cache[path] = result;
    return result;
  };
  /**
   *  @param str: The text contents of the template.
   *  @param opts: An object containing at least "filename" as the path
   *      to the template, and "root" as its basedir.
   */
  prototype.getTemplateFromString = function(str, opts){
    var exports, compiled, __filename, __dirname, __load_template, _this = this;
    __filename = opts.filename;
    __dirname = opts.root;
    this.trackFile(__filename);
    this.deps[__filename] = {};
    __load_template = function(path){
      if (path[0] != '/') {
        path = join(__dirname, path);
      }
      _this.deps[__filename][path] = true;
      return _this.getTemplate(path);
    };
    try {
      exports = {};
      compiled = this.getTemplateSourceFromString(str);
      eval(compiled);
      return exports;
    } catch (e) {
      if (e instanceof SyntaxError) {
        console.log(compiled);
      }
      throw e;
    }
  };
  return BasicFileEnvironment;
}(Environment));
exports.defaultEnvironment = new Environment();
exports.fileOutputEnvironment = new Environment({
  filters: "require('jinjs/lib/filters')",
  loader: "require"
});
exports.Environment = Environment;
exports.BasicFileEnvironment = BasicFileEnvironment;